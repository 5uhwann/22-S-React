# 7/20일 학습 내용

## 브라우저 렌더링 과정

이 과정은 우리가 HTML , CSS , JAVASCRIPT 파일을 통해 브라우저에 보여지는 과정을 설명한다

### 서버에 요청

브라우저 주소창에 URL을 입력하면 브라우저를 통해 그 사이트에 들어가는 것이랑 마찬가지이다 일단 브라우저는 URL의 호스트 이름이 DNS (도메인 이름 시스템) 를 통해 IP 주소로 변환되고 이 IP주소를 갖는 서버에게 요청을 전송한다

이때 서버에게 필요한 리소스 ( HTML , CSS , 자바스크립트 , 이미지 , 폰트 등 정적 파일 또는 동적 데이터)를 서버에 요청한다.

---

### HTML 문서로 파싱하여 DOM 생성

HTML 문서는 문자열로 이루어진 순수한 텍스트다 우리가 실제로 브라우저에 시각적인 픽셀로 렌더링 하려면 HTML의 문서를 객체로 변환하여 메모리에 저장해야한다. 브라우저가 이해할 수 있는 DOM을 생성한다 

> **→**여기서 HTML 문서를 파싱(해석)하여 DOM으로 만든 과정은 ?
> 

서버가 요청을 받으면 그 HTML파일을 읽어 들여 메모리에 저장된 바이트를 응답 . 바이트로 응답받은 브라우저는 바이트 형태의 HTML 문서는 문자열로 변환 . 문자열로 변환된 HTML을 코드 최소 단위인 토큰들로 분해 후 토큰들을 객체로 변환해서 노드를 생성 . 근데 이때 이 HTML의 요소는 중첩 관계를 갖는다 (ex) 형제관계 , 부모 관계 태그 사이 태그 등등 ..) 이걸 반영하여 모든 노드들을 트리 자료구조로 구성하고 이것을 DOM이라 한다

---

### CSS파싱과 CSSOM 생성 , 렌더트리 생성

CSS 파싱과 CSSOM 생성

HTML을 처음부터 한줄 씩 파싱해서 DOM을 생성하지만 CSS를 로드하는 link or style 태그를 만나면 DOM 생성을 일시 중지하고  CSS를 HTML과 동일한 파싱 과정을 거친다 (바이트 → 문자 → 토큰 → 노드→ CSSOM)  CSS 파싱하여 CSSOM을 생성하면 다시 DOM 생성 재개

렌더 트리 생성

HTML과 CSS를 파싱하여 각각 DOM과 CSSOM을 생성하고 렌더링을 위해 렌더 트리로 결합된다. 렌더트리는 브라우저 화면에 렌더링 되는 노드만으로 구성 된다 ( display:none; 이런건 표시 x)  그 이후  레이아웃을 계산과 페인팅이 실행된다. 또한 이 렌더링 과정은 노드 추가, 삭제,뷰포트 크기 변경으로 인해 반복해서 실행될 수 있다.

---

### 자바 스크립트 파싱, 실행 , 문제점

자바스크립트 파싱

DOM을 생성해 나가다 자바스크립트 파일을 로드하는 script 태그를 만나면 DOM 생성을 일시 중단하고 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진(구글 크롬 , Node.js의 V8)에 제어권을 넘기고 파싱과 실행이 종료되면 렌더링 엔진으로다시 제어권을 넘겨 DOM 생성을 재개한다. 

자바스크립트 엔진은 제어권을 넘겨받으면 DOM과 CSSOM을 생성하듯이 AST( 추상적 구문 트리)를 생성한다

자바스크립트 파싱의 문제점

자바스크립트 태그가 나오면 DOM 생성을 멈추는 거니까 태그위치는 중요한 의미를 갖는다. script 태그 위치에 의해 블로킹이 발생한다는 것이다. DOM API인 document.getElementById(’apple’); 에서 DOM 생성을 중간에 멈췄기에 apple인 HTML요소를 파싱하지 않은 상태일 수 있다. 이런 문제로 script 태그를 아래에 놓기도 한다

async / defer 애트리뷰트

async는 HTML파싱과 자바스크립트 파일의 로드가 비동기적으로 동시에 진행되며 HTML의 파싱이 끝나고 자바스크립트 파일의 로드가 완료되면 자바스크립트의 파싱을 진행하며 이때 HTML의 파싱이 중단된다. 단 이 어트리뷰트를 지정하면 로드가 완료된 자바스크립트의 태그부터 먼저 실행되어 순서가 보장되지 않는다.

defer은 HTML 파싱과 자바스크립트 파일 로드가 비동기적으로 동시에 진행되는건 같지만 DOM 생성이 완료된 직후에야 자바스크립트를 파싱하고 실행해서 순서를 보장할 수 있다

‘

## 함수 실행 과정

함수를 호출하면 함수 코드가 평가되어 함수 실행 컨텍스트가 실행된다. 생성된 함수 실행 컨텍스트는 실행 컨텍스트 스택( 콜 스택)에 푸시되고 함수 코드가 실행된다. 함수 코드의 실행이 종료되면 콜 스택에서 팝되어 제거된다.

스택이란 ? 

자료구조로 생각하면 좋음

![Untitled](7%2020%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%200c2cf872f37c4827a921ff82b4a2d509/Untitled.png)

---

## 동기 처리 방식

위와 같이 함수가 평가되고 스택에 푸시되어 실행을 한다. 실행 중인 실행 컨텍스트를 제외하면 나머지 모든 실행 컨텍스트는 대기중인 태스크큐에 있다  근데 이때 이 스택을 자바스크립트 엔진은 단 하나만 갖고있다. 즉 자바스크립트 엔진은 한번에 하나의 테스크만 실행할 수 있는 싱글 스레드 방식으로 동작한다. 싱글 스레드 방식은 한번에 하나의 태스크만 실행이 가능하기에 블로킹(중단 현상)(제어권을 넘기는 것)이 발생한다.

예를 들어 delay가 3초후에 foo 함수를 호출하는 sleep 함수가 있다. 이때 sleep 함수 다음에 실행될 bar함수는 3초 이상 호출되지 못하고 블로킹된다. 

그러면 sleep이 실행되서 딜레이까지 거치고 foo가 실행된 후에야 bar가 실행되는거니까 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹된다는 단점이 있다

---

## 비동기 처리 방식

먼저 비동기처리는 현재 실행중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식이다.

블로킹이 발생하지 않는다는 장점이 있지만 태스크의 실행 순서가 보장되지 않는 단점이 있다

타이머 함수인 setTimeout , setInterval , HTTP , 이벤트 핸들러가 비동기 처리 방식으로 진행한다.

**비동기 처리는 어떤 순서로 진행될까?**

```jsx
function foo(){
console.log('foo')};

function bar(){
console.log('bar')};

setTimeout(foo , 4);
bar();
```

1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시된다
2. setTimeout 함수의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시되어 실행중인 실행 컨텍스트가 된다. 브라우저 web api인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성한다
3. 타이머 설정과 타이머가 만료되면 브라우저가 콜백 함수를 태스크 큐에 푸시한다 foo함수는 태스크 큐에 대기한다 ( foo 함수는 콜스택이 비어야 실행할 수 있다)   (브라우저가 실행 4와 병행처리)
4. bar 함수가 호출되어서 bar 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 실행중인 실행 컨텍스트가 된다 bar 함수가 종료되면 콜스택에서 팝이되고 이때도 foo 함수는 태스크큐에서 대기  (자바스크립트 엔진이 실행 3과 병행 처리) 
5. 전역 코드 실행이 종료되고 콜 스택에 아무런 실행 컨텍스트가 존재하지 않을 때 foo 함수의 실행 컨텍스트가 생성되고 실행 중인 실행 컨텍스트가 된다. 그리고 팝된다.

브라우저는 동시에 처리하고 자바스크립트 엔진은 싱글 스레드 방식으로 처리를 한다

위의 예시처럼 타이머를 설정하고 만료되면 콜백함수를 태스크 큐에 등록하는걸 브라우저가 하니까 비동기 방식으로 실행 될 수 있는 것이다.(이때 자바스크립트 엔진은 bar을 실행하고)

자바스크립트 엔진은 콜스택과 힙으로만 구성돼서 태스크 요청이오면 콜스택을 통해서 요청된 작업을 순차적으로 진행할 뿐

브라우저는 이벤트 루프와 태스크큐로 인해 대기중인 함수가 있다면 콜스택으로 이동시키거나(이벤트 루프) 비동기함수의 콜백함수 또는이벤트 핸들러를 일시적으로 보관한다(태스크 큐)

## Ajax란?

자바스크립트를 사용하여 브라우저가 서버에게 비동기방식으로 데이터를 요청하고

서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을

말한다.

전통적인 방식 

변경할 필요가 없는 부분까지 포함한 완전한 HTML을 서버로부터 매번 전송 받고 변경할 필요가 없는 부분까지 처음부터 다시 렌더링한다. 동기방식으로 작동되기에 블로킹이 발생. 즉 웹 페이지를 새로 보여줬던 것

Ajax 방식

불필요한 데이터 통신을 발생하지 않고 변경할 필요가 없는 부분은 다시 렌더링 하지 않는다. 그렇기에 비동식 방식으로 동작하여 블로킹이 발생하지도 않는다

---

## JSON

http 통신을 위한 텍스트 데이터 포맷  데이터 형태라고 생각하면 된다. 순수 텍스트며 문자열을 큰따옴표로만 써야한다

+JSON 대신 XML도 있지만 (이 XML은 데이터 이동 구조 및 저장을 설명하는 순수 텍스트 파일) 은    이제 사용을 안함

JSON.stringify 

json의 메서드로 객체를 JSON 포맷의 문자열로 변환시키는 것 (직렬화)

```jsx
const obj={
name:'Lee',
age:20,};

const json= JSON.stringify(obj);
console.log(json);
//string{"name" : "Lee" , "age":20}
```

JSON.parse

json 포맷의 문자열을 객체로 변환하는 것 ( 역직렬화) 

문자열을 배열 객체로 변환도 가능 

```jsx
const parsed = JSON.parse(json);
console.log(parsed);
//{ name: "Lee",age:20}
```

---

## XMLHttpRequest

XMLHttpRequest는 HTTP 요청 전송 기능을 기본으로 제공하는 객체

현재 fetch api를 사용해서 이 객체는 많이 사용 안함

## JSX란?

javascript xml로 쉽게 말해서 html 문법을 자바스크립트  코드 내부에 쓴 것

JSX는 React “엘리먼트”를 생성하고 이것은 일반 객체이다

## JSX를 자바스크립트로 변환

1. Node.js와 그 외 빌드 툴 등으로 구성된 개발 환경을 구축하여 리액트로 개발하는 것 빌드 툴을 이용해 JSX로 작성된 코드들이 JS로 변환되며 파일처럼 참조할 수 있도록 디스크에 저장
2. 브라우저가 JSX를 JS로 자동 변환하게 하는 법 (실제로 사용 X cdn을 이용하는 방식이여서)

  JSX는 브라우저에서 실행되기저 바벨(컴파일러)을 사용하여 자바스크립트 형태로 변환된다

## ReactDOM.render(element,container[callback])

개발자가 작성한 JSX를 화면에 렌더링 하기 위해서는 ReactDOM.render() 함수를 사용해야한다

element : JSX로 작성한 화면에 출력할 내용

container: 첫번째 인자인 JSX를 렌더링해서 보여줄 DOM안의 위치

```jsx
ReactDom.render(
<h1>Hello world<h1>,
document.body);
```

이 함수를 이용하면 HTML , CSS , JS로 만들어지고 이는 브라우저가 이해할 수 있다

## JSX 장점

1. 보기 쉽고 익숙하다
2.  높은 활용도