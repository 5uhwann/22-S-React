# JS 
## 자바 스크립트란?
자바 스크립트란 정적, 다시 말해 변하지 않는 html 문서의 내용을 프로그램을 통해 동적으로 변경하거나 사용자와의 상호작용을 담당하게 된다.
*	 객체 기반의 동적 프로그래밍 언어이며 변수 선언시에 타입의 선언이 필요하지 않다. 이를 인터프리터 언어라 한다. 
*	 객체지향 프로그래밍과 함수형 프로그래밍을 모두 표현할 수 있다.
### 
	객체 지향 프로그래밍이란, 실세계를 모델링하여 객체로 만들어서 상호작용하는 언어이고  함수형은 프로그램의 계산 과정을 수학 함수 형태로 프로그래밍 되어있는 것을 말한다. 스칼라, 하스켈
*	 이벤트를 처리하고 사용자와의 상호작용을 가능하게 한다.
###
	이벤트란 웹 내의 특정한 요소와 사용자와의 상호작용을 의미하는 것으로 마우스 커서 올려놓기, 키보드에서 키 선택하기, 창의 크기 조정 등이 여기에 해당합니다.
*	 AJAX 기술을 이용하여 실시간 통신 기능을 제공한다. 
	 이는 웹 화면을 갱신하지 않고도 필요한 데이터를 서버로 보내고 가져오는 것을 가능하게 해 주는데 이때  서버에 보내는 방식은 동기화 되지 않고 요청-응답 사이에 다른 일을 진행할 수 있게 한 뒤 응답이 오면 그 이후 작업을 진행합니다. 
###
	이때 데이터를 전송하는 방식에는 크게 3가지가 있다.

	1.  우선 CSV 방식이다. 데이터의 속성을 먼저 정의하고 ‘ . ‘ 을 식별자로 사용하여 줄바꿈을 기준으로 데이터를 나눈다. 용량은 적지만 가독성은 떨어진다는 단점이 있다.

	2. 다음은 XML 형식이다. CSV가 가독성이 좋지 않다는 문제점을 가지고 있어서 이를 개선하기 위해 사용하는 데이터 형식이다. 속성에 태그를 붙여주어 가독성이 좋아졌지만 용량이 늘어나고 데이터가 더 많아졌다.

	3. JSON 형식으로 데이터를 자바스크립트의 객체 형태로 전송한다. 앞선 두 방식의 단점을 최소화한 형식으로 가독성도 좋고 용량도 크지 않지만 데이터 양이 많으면 분석속도가 떨어진다는 단점은 XML형식과 같다.

참조사이트: https://www.nextree.co.kr/p9521/

## Js의 변수선언과 변수 업데이트
 let 변수 = 값; 자바와는 다르게 변수의 타입에 상관없이 let 명령어를 사용해서 변수를 선언하는 것을 알 수 있다. 재할당, 즉 변경이 가능하다는 점이 const와는 차이점이다. 그 외의 작성 방식은 자바에서의 그것과 같다. 물론 문자열은 let 변수 = “문자열”; 의 형태로 적어주어야 한다.
const 변수 = 값; JS에서의 상수값을 선언할 때 사용된다. 선언한 이후에는 변하지 않는 값이다. 
var 변수 = 값; 
특이하게 문자열의 경우 문자열 내의 글자들이 전부 인덱스화 되어서 각각에 개별적으로 접근하는 것이 가능한데 예시를 들자면 
```html
let animal =”cute cat”;
```
 으로 문자열이 선언되어 있고 이후에
 ```html
  animal[2];
  ```
   를 사용하면 그 값은 animal 변수의 2번째 인덱스에 들어가 있는 ‘t’를 반환하게 된다. 
자바스크립트는 변수의 내용의 타입이 변하는 것도 가능하다. 
이외의 변수명의 표기에 대한 규칙은 여느 언어와 같다

## JS의 메서드
자바 스크립트에서도 메서드의 실행은 자바와 같이 변수.메서드() 의 형태로 이루어진다.  
```html
	let sentence = “hi, my name is yuumi!”;
	console.log(` ${ sentence.toUpperCase() } `)
->”HI, MY NAME IS YUUMI!”
```
또한 sentence.trim().toUpperCase() 와 같이 메서드의 중복 적용이 가능하다.
참고로 자바에서의 printf의 기능을 대체하는 것이 있는데 바로 `number is ${ 변수 }.`와 같이 사용하는 것이다. 이렇게 하면 문자열은 number is 변수의 값. 으로 출력된다. 
식별자에서 독특한 건 ==과 ===이다. 타입에 대하여 덜 까다로운 탓에 있는 것 같다. == 식별자(이중 등호 식별자)는 값을 비교 할 때 타입을 가리지 않고 내용만을 본다. 가령 숫자 타입의 5 가 있고 문자열의 5가 있을 때 이 둘을 이중 등호 연산자로 비교한다면 두 타입이 같아지도록 강제 변환된다. 그러나 ===(삼중 등호 식별자)로 판별하게 된다면 두 값은 그 값이 같아도 타입이 다르기 때문에 서로 같지 않다고 나올것이다. 
## DOM (document object model)
Dom 이란 문서 객체 모델이라는 뜻으로 문서 객체와 관련된 객체들의 집합이다. 이를 조금 더 직관적으로 말하자면 html이 어떠한 구조로 이루어져 있는지를 모델링한 것이라고 할 수 있다. 이를 tree 라는 형식의 자료구조로 나타낸다. Tree형 구조에선 뿌리가 되는 root 노드에서 시작하여 아래로 포함하며 퍼져나가는데 위쪽의 노드는 부모 노드, 아래쪽의 노드는 자식 노드라 한다. 이를 통해 DOM객체에 먼저 접근하여 필요한 노드를 찾는다. 이를 통해 html에게 새로운 요소나 속성의 추가나, 제거, 스타일의 변경등 문서의 수정등의 작업을 할 수 있다.

### 동적 문서 객체 생성
DOM은 기본적으로 웹 브라우저가 html의 태그를 읽으면서 생성한다. 하지만 사용자와의 상호작용이나 시간의 변화에 따라 페이지의 변화를 주고 싶은 경우, 즉 기존에는 없던 문서객체를 자바스크립트를 통해 생성하고자 할 때 DOM에 동적으로 문서객체를 생성하는 것이 된다.

+)노드란 root 노드를 포함한 트리구조 내의 모든 개체를 노드라 한다. 태그, 속성, 내용등이 포함된다
## DOM 사용법
### 요소의 생성
```html
document.createElement(“tag ex) h1, div, p…”)
```
을 통해 태그의 생성 후 
```html
document.createTextNode(“text요소”)
```
 를 이용해 객체에 text요소를 추가한다. 
```html
OM요소a.appendChild(DOM요소b):
```
 요소b를 요소a로 만든다
```html
요소.setAttribute(속성,값)
요소.getAttribute(속성)
요소.removeAttribute(속성): 
```
요소의의 해당속성을 각각 설정, 반환, 제거한다.
```html
Ex) 요소.setAttribute(“style”, “background-color:green;” );
```
Q) Property가 dom 내에서 존재한다고 했는데 setProperty가 아니라 attribute인가요? 
A) attribute 는 
자바스크립트에서도 import ~~~처럼 다른 메서드를 사용할 때 api를 들여와야 하는 경우가 있나요?
	기본 내장 api가 있고 서드파티 api가 있다. 대부분은 내장 api이기 때문에 따로 import 해줄 필요는 없지만 서드파티 api는 필요하다.
## Event Handling 
 이벤트란 사용자의 어떤 행위, 대표적으로 클릭, 키보드 입력, 화면 크기 조정을 의미한다. 이에  JS에서는 이벤트 핸들러를 통해서 수많은 이벤트를 처리한다. 이때 이벤트 핸들링은 다음과 같은 과정으로 이루어진다. 
1.	이벤트를 받아서 처리할 요소를 선택
2.	선택한 요소가 반응할 이벤트를 지정
3.	이벤트의 발생시 실행될 코드의 작성
2번의 과정을 바인딩이라 하는데 여러가지 방법을 통해 요소에 이벤트를 바인딩할 수 있다.
## 
1.	우선 HTML 이벤트 핸들러를 이용한 방법이다.
```html
<button class=”btn” onclick=”myFunction()”>
```
JS에서 myFunction()이라는 함수를 미리 구현해 놓은 뒤 버튼에 온클릭 이벤트가 발생하였을 때 myFunction이라는 함수가 호출되어 작동하는 방법이다. 하지만 HTML에서도 가능한 스타일 작업을 굳이 HTML문서 내에서 하지 않고 CSS에다가 하는것과 비슷하게 자바 스크립트도 보통은 코드를 분리하여 관리하기 때문에 좋은 방식이라 할 수는 없다.
2.	위와 같은 문제 때문에 JS에서 사용되는 DOM요소에 property, 특성의 형태로 바인딩을 해줄 수도 있다. 
```html
element.on이벤트이름 = myFunction(){…}
```
그러나 이보다 다음의 방식이 더 많이 사용된다.

3.	바로 DOM요소에 addEventKistener 메서드를 호출하여 이벤트의 바인딩과 수행함수를 작성하는 것이다. 
```html
element.addEventListener(“이벤트이름”,myfunction(){…}, [,boolean]);
```
이 방식이 지금의 바닐라 js(외부 라이브러리나 프레임워크를 쓰지 않는 순수 js)에서 가장 많이 사용된다. 사용 방법은 예시의 다음과 같다. 이벤트의 이름과 실행시키고자 하는 함수를 적는 것 까지는 앞선 두 방식과 같은데 마지막에 불리언타입의 무언가를 적는 것이 보인다. 이는 이벤트 버블링과 이벤트 캡쳐링에 관해 적는 부분이다. 이벤트 버블링은 DOM트리에서의 자식요소에서 이벤트가 발생한다면 부모요소도 같은 이벤트의 영향을 받게 되는 것을 말한다. 이벤트 캡쳐링은 반대로 부모요소에서 자식노드로의 이벤트 연계 흐름을 말한다. 만약 불리언의 값을 적는 부분에 false를 적는다면 이벤트 버블링을, true를 적는다면 이벤트 캡쳐링을 적는다. 대부분의 상황에선 false를 적게된다. 큰 버튼이 작은 버튼을 둘러싸고 있는 상황을 생각해볼 때 상식적이라면 큰버튼을 눌렀는데 작은버튼도 함께 눌러지게 코드를 작성하지는 않기 때문이 아닐까? 

### 여담으로 DOM에서의 createTextNode(), append(), after()와 같이 기존에는 없던 요소를 추가해 주는 메서드를 이용해서 동적으로 요소를 생성한 이후에, 해당 요소에는 이벤트 바인딩이 적용되지 않기 때문에 재바인딩을 해주어야 한다.

도움을 준 사이트:  https://victorydntmd.tistory.com/85
https://blog.naver.com/PostView.naver?blogId=yuyyulee&logNo=221584032543&redirect=Dlog&widgetTypeCall=true&directAccess=false
https://codingnuri.com/javascript-tutorial/html-dom-events-and-event-handling.html
http://www.tcpschool.com/jquery/jq_event_concept
## ES6 문법
ES6 문법은 2015년에 공개된 ECMAScript의 버전이다. 이는 자바스크립트의 표준, 규격을 나타내는 용어이다. 
1.	const와 let 키워드
변수 선언시 사용하는 키워드이다. 기존에는 var 키워드만을 이용하여 변수를 선언하였지만 재할당을 불가능하게 하기 위해서 상수인 const를 추가하였다. 이와 반대로 let은 얼마든지 재할당이 가능한 변수이다. 기존의 var 키워드만을 사용했을 때보다 무엇이 앞으로 재할당 될 가능성이 있고 무엇이 없는지를 파악할 수 있어 조금 더 예측 가능한 코딩을 가능하게 해주는 키워드이다.
2.	템플릿 리터럴 
백틱( ` )을 이용, 문자열 내에서의 변수를 표현하기 위해 사용한다. 
```html
const myName = ‘ minsu ‘
let greeting = ` 안녕! 내 이름은 ${ myName }(이)야.`;
```

3.	객체 리터럴 
객체의 생성시 기존보다 간결한 코드로 선언이 가능하다. 자바 스크립트에서는 다음과 같이 객체를 생성한다. 
```html
const 변수명 = new 함수();
```
```html
function Plus(a1,a2){
this.a1 = a1;
this.a2 = a2;
this.result = ()=>{
		return this.a1 + this.a2;
		}
}
const p = new Plus(1, 2,);
```

이러한 코드는 자바에서와 마찬가지로 객체에서 따로 생성자를 만들어서 객체를 생성할 때 전달받는 매개 변수를 어떻게 처리할 것인지에 대하여 정리해주어야 한다. 그러나 객체 리터럴을 통해 객체를 생성한다면 다음과 같이 간결한 코드가 나온다.
```html
const plus = {a1: 1, a2: 2};
console.log(plus);
``` 
4.	화살표 함수
함수 표현식을 화살표를 이용하여 간결하게 나타낸다.
+)return과 {}는 함께 생략하여 =>로 대신 쓸 수가 있다.
5.	구조 분해 할당
구조 분해 할당은 객체와 배열로부터 각각의 값, 즉 프로퍼티를 쉽게 꺼낼 수 있는 문법이다. 
```html
const toktoKhanCompant = {
company: “ToKToKHan”
name: ” .dev”
age: 1,
};
```,
다음과 같은 객체를 생성하였다고 할 때 원래는 위의 방식으로 하나하나 변수를 할당하여 프로퍼티에 접근하여야 한다
```html
let compant = contacts.company;
let name = contacts.name;
let age = contacts.age;
``` 
그러나 ES6의 구조 분해 할당을 이용한다면
```html
let { compant, name, age } = ToktokhanCompany
```
이렇게 각각에 새로운 변수의 할당이 필요하지 않고 해당 프로퍼티의 이름 그대로 호출하여도 사용 가능하게 된다.
6.	promise
promise는 비동기 함수( 서버에 전달한 함수가 실행될 동안 사용자가 다른 작업을 할 수 있는 상태의 연결이다)의 연산이 완료되었을 때, 이후에 처리할 함수나 에러를 처리하기 위한 함수를 설정한는 모듈이다. 기존에는 비동기 처리를 위해 콜백함수(인자로 넘겨지는 함수)를 이용했다. 이럴 경우 문제가 생기는데 인자로 넘어가는 과정이 여러 번 중첩되면 코드가 복잡해지는 일명 콜백 지옥이 발생한다. 
```html
setTimeout(function() {
console.log(‘ How are you/ ’);
setTimeout(function() {
		console.log(‘I am fine.’);
				setTimeout(function() {
					console.log(‘Thank you.’);
setTimeout(function() {
console.log(‘And you?’);
}, 3000);
}, 3000);
}, 3000);
}, 3000);
```






콜백 내부에 연속적으로 콜백이 들어있으니 변경도 어렵고 가독성 측면에서도 보기 좋지 않다. 이러한 경우 promise나 async를 통해서 개선이 가능하다. 
promise의 세가지 상태
비동기 함수의 상태는 이행도 거절도 되지 않은 상태인 초기상태의 pending(대기), 비동기 연산이 성공적으로 완료된 상태, 결과값을 반환하는 fulfilled(이행), 그리고 비동기 연산에 실패한 상태로 에러를 반환하는 rejected(실패)상태가 있다. 
```html
promise.then(), pomise.catch(), promise.finally()
```
 는 promise가 확정되었을 때의 액션들을 서로 연결해준다. 
then(),catch(): resolve시의 콜백함수와 reject시의 콜백함수, 이렇게 두가지의 인자를 받을수가 있다. 사용법은 다음과 같다
```html
비동기함수의_이름.then(resolve시 수행할 메소드) .catch(reject시 수행할 메소드);
```
7.	async와 await
	async 는 function 앞에 위치한다. 이 과정을 통해 함수 내부는 전부 비동기로 바뀌게 된다. 간단히 하면 함수 내부 전체에 promise 구조가 씌워지는 것이다. promise를 이용하여 처리하는 것과의 차이점은 더 이상 .then과 같은 것을 사용하지 않아도 동기처리를 할 수 있다는 것이다. 
```html 
function p(){
return new Promise((resolve, reject)=>{
resolve(‘hello’);
});
}
p().then((n)=>console.log(n));
```
위와 같던 식이 async를 이용하면 함수 내부에 모두 프로미스가 씌워지게 되어
```html
async function p(){
	return ‘hello ’;
}
p().then((n)=>console.log(n));
```
과 같이 쓸 수가 있다. 다만 아직 .then()가 있는 이유는 async구문 내에서 비동기로 처리되는 부분 앞에 await을 붙여줘야 하기 때문이다. 


도움을 준 사이트: https://tech.toktokhan.dev/2021/08/22/es6/
		https://hanamon.kr/javascript-es6-%EB%AC%B8%EB%B2%95/
		https://velog.io/@kimhscom/JavaScript-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-ES6-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC
